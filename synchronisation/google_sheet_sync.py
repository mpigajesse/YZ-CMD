import os
import gspread
from google.oauth2.service_account import Credentials
from django.conf import settings
from django.utils import timezone
from client.models import Client
from commande.models import Commande, EtatCommande, EnumEtatCmd, Panier
from parametre.models import Operateur, Ville, Region
from synchronisation.models import SyncLog, GoogleSheetConfig
import pandas as pd
from datetime import datetime, timedelta
from django.db import transaction
from django.db.models import Q
import re

class GoogleSheetSync:
    """Classe pour g√©rer la synchronisation avec Google Sheets"""
    
    def __init__(self, sheet_config, triggered_by="admin", verbose=False):
        self.sheet_config = sheet_config
        self.triggered_by = triggered_by
        self.verbose = verbose  # Contr√¥le l'affichage des messages d√©taill√©s
        self.records_imported = 0
        self.errors = []
        self.warnings = []
        
        # Nouveaux attributs pour les d√©tails d'ex√©cution
        self.start_time = None
        self.end_time = None
        self.total_rows = 0
        self.processed_rows = 0
        self.skipped_rows = 0
        self.sheet_title = ""
        self.execution_details = {}
        
        # Nouveaux compteurs pour distinguer les types d'op√©rations
        self.new_orders_created = 0      # Nouvelles commandes cr√©√©es
        self.existing_orders_updated = 0  # Commandes existantes mises √† jour
        self.existing_orders_skipped = 0  # Commandes existantes inchang√©es
        self.duplicate_orders_found = 0   # Commandes en double d√©tect√©es
        self.protected_orders_count = 0   # Commandes prot√©g√©es contre la r√©gression d'√©tat
    
    def _log(self, message, level="info"):
        """Log conditionnel selon le mode verbose"""
        if self.verbose:
            print(f"üîÑ {message}")
        # Toujours enregistrer les erreurs dans self.errors
        if level == "error":
            self.errors.append(message)
        
    def authenticate(self):
        """Authentification avec l'API Google Sheets"""
        try:
            scope = [
                'https://www.googleapis.com/auth/spreadsheets.readonly',
                'https://www.googleapis.com/auth/drive.readonly'
            ]
            credentials = Credentials.from_service_account_file(
                settings.GOOGLE_CREDENTIALS_FILE, 
                scopes=scope
            )
            client = gspread.authorize(credentials)
            return client
        except Exception as e:
            self.errors.append(f"Erreur d'authentification: {str(e)}")
            return None
    
    def get_sheet(self, client):
        """R√©cup√®re la feuille Google Sheet"""
        try:
            # Ouvrir par URL ou par cl√© selon ce qui est fourni
            if 'docs.google.com' in self.sheet_config.sheet_url:
                spreadsheet = client.open_by_url(self.sheet_config.sheet_url)
            else:
                spreadsheet = client.open_by_key(self.sheet_config.sheet_url)
                
            # S√©lectionner la feuille par nom
            worksheet = spreadsheet.worksheet(self.sheet_config.sheet_name)
            return worksheet
        except Exception as e:
            self.errors.append(f"Erreur d'acc√®s √† la feuille: {str(e)}")
            return None
    
    # M√©thode parse_product supprim√©e car plus n√©cessaire avec la refactorisation des articles
    # Les produits sont maintenant stock√©s directement dans la commande sans parsing complexe
    
    def _parse_date(self, date_str):
        """Parse une date depuis diff√©rents formats possibles"""
        if not date_str:
            return timezone.now().date()
        
        # Formats de date possibles
        date_formats = [
            '%d/%m/%Y',
            '%d-%m-%Y',
            '%Y-%m-%d',
            '%d/%m/%y',
            '%d-%m-%y',
            '%Y/%m/%d',
            '%m/%d/%Y',
            '%m-%d-%Y',
        ]
        
        for date_format in date_formats:
            try:
                parsed_date = datetime.strptime(date_str.strip(), date_format)
                return parsed_date.date()
            except ValueError:
                continue
        
        # Si aucun format ne fonctionne, retourner la date actuelle
        self.errors.append(f"Format de date non reconnu: {date_str}")
        return timezone.now().date()
    
    @staticmethod
    def clean_phone_number(phone_str):
        """Nettoie et valide un num√©ro de t√©l√©phone"""
        if not phone_str:
            return ''
        
        # Convertir en string et nettoyer
        phone = str(phone_str).strip()
        
        # Supprimer les caract√®res non num√©riques courants (espaces, tirets, points, parenth√®ses)
        phone = re.sub(r'[\s\-\.\(\)\+]', '', phone)
        
        # Limiter √† 30 caract√®res maximum (limite du mod√®le Client)
        if len(phone) > 30:
            phone = phone[:30]
        
        return phone
    
    def _clean_phone_number(self, phone_str):
        """Nettoie et valide un num√©ro de t√©l√©phone avec logging des warnings"""
        phone = self.clean_phone_number(phone_str)
        
        # Log warning si le num√©ro a √©t√© tronqu√©
        if phone_str and len(str(phone_str).strip()) > 30:
            self.warnings.append(f"Num√©ro de t√©l√©phone tronqu√©: {phone_str} -> {phone}")
        
        return phone
    
    def process_row(self, row_data, headers):
        """Traite une ligne de donn√©es - nouvelles commandes uniquement, √©vite les doublons"""
        try:
            # Cr√©er un dictionnaire avec les donn√©es de la ligne
            data = dict(zip(headers, row_data))
            
            # Debug: Afficher les donn√©es re√ßues
            if self.verbose:
                print(f"üîç Donn√©es re√ßues pour la ligne : {data}")
            
            # V√©rifier si la commande existe d√©j√† - essayer diff√©rentes variantes de cl√©s
            order_number = data.get('N¬∞ Commande') or data.get('Num√©ro') or data.get('N¬∞Commande') or data.get('Numero')
            if not order_number or not order_number.strip():
                self._log(f"Ligne rejet√©e : num√©ro de commande manquant ou vide. Donn√©es re√ßues: {data}", "error")
                return False
            
            self._log(f"V√©rification commande {order_number}")
            
            # V√©rifier si la commande existe d√©j√†
            existing_commande = Commande.objects.filter(num_cmd=order_number).first()
            if existing_commande:
                # Commande existe d√©j√† - pas d'insertion
                self._log(f"Commande {order_number} existe d√©j√† (ID YZ: {existing_commande.id_yz}) - IGNOR√âE")
                self.duplicate_orders_found += 1
                
                # TOUJOURS mettre √† jour les √©tats, m√™me si les autres donn√©es sont inchang√©es
                self._log(f"Mise √† jour des √©tats pour commande existante {order_number}")
                success = self._update_existing_command(existing_commande, data, headers)
                if success:
                        self.existing_orders_updated += 1
                return success
            
            # R√©cup√©rer ou cr√©er le client
            client_phone_raw = data.get('T√©l√©phone', '')
            client_phone = self._clean_phone_number(client_phone_raw)
            client_nom_prenom = data.get('Client', '').split(' ', 1) # Tente de s√©parer nom et pr√©nom
            client_nom = client_nom_prenom[0] if client_nom_prenom else ''
            client_prenom = client_nom_prenom[1] if len(client_nom_prenom) > 1 else ''
            
            client_obj, created = Client.objects.get_or_create(
                numero_tel=client_phone,
                defaults={'nom': client_nom, 'prenom': client_prenom, 'adresse': data.get('Adresse', '')}
            )
            # Mettre √† jour les infos client si la fiche n'est pas nouvelle et des donn√©es sont dispo
            if not created:
                if client_nom and client_obj.nom != client_nom:
                    client_obj.nom = client_nom
                if client_prenom and client_obj.prenom != client_prenom:
                    client_obj.prenom = client_prenom
                if data.get('Adresse') and client_obj.adresse != data.get('Adresse', ''):
                    client_obj.adresse = data.get('Adresse', '')
                client_obj.save()

            # R√©cup√©rer la ville du fichier sans essayer de la lier √† la table Ville
            ville_nom = data.get('Ville', '').strip()
            ville_obj = None  # On ne lie plus √† un objet Ville

            # G√©rer le prix de mani√®re s√©curis√©e
            try:
                total_cmd_price = float(data.get('Prix', 0)) or float(data.get('Total', 0))
            except (ValueError, TypeError):
                total_cmd_price = 0.0

            # Cr√©er une NOUVELLE commande (v√©rification d√©j√† effectu√©e)
           
            commande = Commande.objects.create(
                num_cmd=order_number,
                date_cmd=self._parse_date(data.get('Date Cr√©ation', '') or data.get('Date', '')),
                total_cmd=total_cmd_price,
                adresse=data.get('Adresse', ''),
                client=client_obj,
                ville=None,
                ville_init=data.get('Ville', '').strip(),
                produit_init=data.get('Produit', ''),
                origine='SYNC',
                last_sync_date=timezone.now() # D√©finir la date de derni√®re synchronisation
            )
            self._log(f"‚úÖ NOUVELLE commande cr√©√©e avec ID YZ: {commande.id_yz} et num√©ro externe: {commande.num_cmd}", "info")
            self.new_orders_created += 1

            # Parser le produit et cr√©er l'article de commande et le panier
            # Avec la refactorisation des articles, on ne cr√©e plus d'articles
            # On stocke seulement les informations du produit dans la commande
            product_str = data.get('Produit', '').strip()
            
            if product_str:
                self._log(f"Produit d√©tect√© pour la commande {commande.num_cmd}: {product_str}")
                # Stocker le produit dans la commande sans cr√©er d'article
                commande.produit_init = product_str
                commande.save(update_fields=['produit_init'])
            else:
                self._log(f"Aucun produit sp√©cifi√© pour la commande {commande.num_cmd}")
                # Marquer la commande comme n'ayant pas de produit
                commande.produit_init = "Produit non sp√©cifi√©"
                commande.save(update_fields=['produit_init'])

            # Cr√©er un panier vide pour la commande
            # SUPPRIM√â : Un panier ne peut pas √™tre vide selon le mod√®le (champs article, quantite, sous_total obligatoires)
            # Le panier sera cr√©√© plus tard quand des articles seront ajout√©s √† la commande
            self._log(f"Pas de panier cr√©√© pour la commande {commande.num_cmd} - sera cr√©√© lors de l'ajout d'articles")

            # Si un op√©rateur est sp√©cifi√© et que la commande est affect√©e
            operator_name = data.get('Op√©rateur', '')
            operateur_obj = None
            if operator_name:
                try:
                    operateur_obj = Operateur.objects.get(nom_complet__iexact=operator_name)
                except Operateur.DoesNotExist:
                    self.errors.append(f"Op√©rateur non trouv√©: {operator_name}")

            # Cr√©er l'√©tat de commande selon le statut
            status_from_sheet = data.get('Statut', '')
            if not status_from_sheet or not status_from_sheet.strip():
                # Le statut est obligatoire - rejeter la commande
                error_msg = f"Statut manquant pour la commande {order_number} - la commande est rejet√©e"
                self._log(error_msg, "error")
                # Supprimer la commande cr√©√©e car elle n'est pas valide
                commande.delete()
                return False
            
            # Essayer de mapper le statut, mais √™tre plus flexible
            status_libelle = None
            etat_created = False
            
            try:
                status_libelle = self._map_status(status_from_sheet)
                self._log(f"Statut reconnu: {status_libelle}")
                if status_libelle:
                    # Statut reconnu - cr√©er l'√©tat
                    self._log(f"Cr√©ation de l'√©tat '{status_libelle}' pour la commande {order_number}")
                    etat_created = self._create_etat_commande(commande, status_libelle, operateur_obj)
                    if etat_created:
                        self._log(f"√âtat '{status_libelle}' cr√©√© avec succ√®s pour la commande {order_number}")
                    else:
                        self._log(f"√âchec de cr√©ation de l'√©tat '{status_libelle}' pour la commande {order_number}", "error")
                else:
                    # Statut non reconnu mais pas vide - utiliser un statut par d√©faut
                    self._log(f"Statut non reconnu '{status_from_sheet}' pour la commande {order_number} - utilisation du statut par d√©faut 'Non affect√©e'", "warning")
                    etat_created = self._create_etat_commande(commande, 'Non affect√©e', operateur_obj)
                    if not etat_created:
                        self._log(f"√âchec de cr√©ation de l'√©tat par d√©faut pour la commande {order_number}", "error")
            except Exception as e:
                # En cas d'erreur, utiliser le statut par d√©faut
                self._log(f"Erreur lors du mapping du statut '{status_from_sheet}' pour la commande {order_number}: {str(e)} - utilisation du statut par d√©faut 'Non affect√©e'", "warning")
                etat_created = self._create_etat_commande(commande, 'Non affect√©e', operateur_obj)
                if not etat_created:
                    self._log(f"√âchec de cr√©ation de l'√©tat par d√©faut pour la commande {order_number}", "error")

            try:
                # Forcer le rafra√Æchissement depuis la base
                commande.refresh_from_db()
                etat_final = commande.etat_actuel
                
                if etat_final:
                    print(f"‚úÖ √âtat final confirm√©: '{etat_final.enum_etat.libelle}'")
                    print(f"   üìã ID √©tat: {etat_final.id}")
                    print(f"   üìã Date d√©but: {etat_final.date_debut}")
                    print(f"   üìã Date fin: {etat_final.date_fin}")
                else:
                    print(f"‚ùå PROBL√àME: Aucun √©tat final trouv√©!")
                    print(f"   üìã Tentative de r√©cup√©ration manuelle...")
                    
                    # V√©rifier manuellement dans la base
                    from commande.models import EtatCommande
                    etat_manuel = EtatCommande.objects.filter(commande=commande).order_by('-date_debut').first()
                    if etat_manuel:
                        print(f"   üìã √âtat trouv√© manuellement: {etat_manuel.enum_etat.libelle}")
                        print(f"   üìã ID: {etat_manuel.id}")
                        print(f"   üìã Date d√©but: {etat_manuel.date_debut}")
                    else:
                        print(f"   üìã Aucun √©tat trouv√© manuellement!")
                        
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur lors de la v√©rification finale: {str(e)}")
            
            print(f"üìà Compteur de commandes import√©es: {self.records_imported}")
            print(f"üîç === FIN TRAITEMENT LIGNE ===\n")

            self.records_imported += 1
            return True
            
        except Exception as e:
            self.errors.append(f"Erreur lors du traitement de la ligne: {str(e)}")
            return False
    
    def _should_update_command(self, existing_commande, data):
        """D√©termine si une commande existante doit √™tre mise √† jour"""
        # V√©rifier si le statut a chang√©
        current_status = existing_commande.etat_actuel.enum_etat.libelle if existing_commande.etat_actuel else 'Non affect√©e'
        
        # Le statut est obligatoire, donc on doit pouvoir le mapper
        try:
            new_status_raw = self._map_status(data.get('Statut', ''))
            new_status = new_status_raw
        except ValueError as e:
            # Si le statut n'est pas reconnu, ne pas mettre √† jour la commande
            self._log(f"Statut non reconnu lors de la mise √† jour: {str(e)} - commande {existing_commande.num_cmd} non mise √† jour")
            return False
        
        # PROTECTION CONTRE LA R√âGRESSION D'√âTATS
        # Si la commande a d√©j√† un √©tat avanc√©, ne pas la r√©initialiser √† "Non affect√©e" ou "En attente"
        if self._is_advanced_status(current_status) and self._is_basic_status(new_status):
            self._log(f"Protection activ√©e: Commande {existing_commande.num_cmd} a l'√©tat avanc√© '{current_status}' - ne pas r√©gresser vers '{new_status}'")
            self.protected_orders_count += 1  # Incr√©menter le compteur de protection
            # Ne pas mettre √† jour le statut, mais continuer √† v√©rifier les autres champs
            new_status = current_status  # Garder le statut actuel
        
        if current_status != new_status:
            return True
        
        # V√©rifier si le prix a chang√©
        try:
            new_price = float(data.get('Prix', 0)) or float(data.get('Total', 0))
            if abs(float(existing_commande.total_cmd) - new_price) > 0.01:  # Diff√©rence de plus de 1 centime
                return True
        except (ValueError, TypeError):
            pass
        
        # V√©rifier si l'adresse a chang√©
        new_address = data.get('Adresse', '')
        if new_address and existing_commande.adresse != new_address:
            return True
        
        # V√©rifier si la ville_init a chang√©
        new_ville_nom = data.get('Ville', '').strip()
        if new_ville_nom and existing_commande.ville_init != new_ville_nom:
            return True
        
        # V√©rifier si l'op√©rateur a chang√©
        new_operator = data.get('Op√©rateur', '')
        current_operator = existing_commande.etat_actuel.operateur.nom_complet if (existing_commande.etat_actuel and existing_commande.etat_actuel.operateur) else ''
        if new_operator and current_operator != new_operator:
            return True
        
        return False
    
    def _is_advanced_status(self, status):
        """D√©termine si un statut est consid√©r√© comme avanc√© (ne doit pas √™tre r√©gress√©)"""
        advanced_statuses = [
            'Affect√©e', 'En cours de confirmation', 'Confirm√©e', 'En pr√©paration', 
            'En livraison', 'Livr√©e', 'Exp√©di√©e', 'Pay√©', 'Partiellement pay√©'
        ]
        return status in advanced_statuses
    
    def _is_basic_status(self, status):
        """D√©termine si un statut est consid√©r√© comme basique (peut √™tre r√©gress√©)"""
        basic_statuses = [
            'Non affect√©e', 'En attente', 'Erron√©e', 'Doublon', 'Annul√©e', 
            'Report√©e', 'Hors zone', 'Injoignable', 'Pas de r√©ponse', 
            'Num√©ro incorrect', '√âchou√©', 'Retourn√©e', 'Non pay√©'
        ]
        return status in basic_statuses
    
    def _update_existing_command(self, existing_commande, data, headers):
        """Met √† jour une commande existante avec les nouvelles donn√©es (PAS D'INSERTION)"""
        try:
            updated = False
            command_changes = []  # Renomm√© pour √©viter tout conflit
            
            print(f"üîÑ Mise √† jour en arri√®re-plan pour commande existante {existing_commande.num_cmd}")
            
            # Mettre √† jour le prix si n√©cessaire
            try:
                new_price = float(data.get('Prix', 0)) or float(data.get('Total', 0))
                if abs(float(existing_commande.total_cmd) - new_price) > 0.01:
                    old_price = existing_commande.total_cmd
                    existing_commande.total_cmd = new_price
                    command_changes.append(f"Prix: {old_price} ‚Üí {new_price}")
                    updated = True
            except (ValueError, TypeError):
                pass
            
            # Mettre √† jour l'adresse si n√©cessaire
            new_address = data.get('Adresse', '')
            if new_address and existing_commande.adresse != new_address:
                old_address = existing_commande.adresse
                existing_commande.adresse = new_address
                command_changes.append(f"Adresse: '{old_address}' ‚Üí '{new_address}'")
                updated = True
            
            # Mettre √† jour la ville_init si n√©cessaire
            new_ville_nom = data.get('Ville', '').strip()
            if new_ville_nom and existing_commande.ville_init != new_ville_nom:
                old_ville_init = existing_commande.ville_init
                existing_commande.ville_init = new_ville_nom
                command_changes.append(f"Ville: '{old_ville_init}' ‚Üí '{new_ville_nom}'")
                updated = True
            
            # Sauvegarder les changements de la commande
            if updated:
                existing_commande.last_sync_date = timezone.now() # Mettre √† jour la date de derni√®re synchronisation
                existing_commande.save()
                print(f"üìù Commande mise √† jour: ID YZ {existing_commande.id_yz} - Changements: {', '.join(command_changes)}")
            
            # G√©rer le statut de la commande (s√©par√© pour √©viter les conflits)
            status_updated = self._update_command_status(existing_commande, data)
            
            # Mettre √† jour les informations du client si n√©cessaire
            self._update_client_info(existing_commande, data, new_address)
            
            return True
            
        except Exception as e:
            error_msg = f"Erreur lors de la mise √† jour de la commande existante {existing_commande.num_cmd}: {str(e)}"
            self._log(error_msg, "error")
            return False
    
    def _update_operator_only(self, existing_commande, data):
        """Met √† jour seulement l'op√©rateur de l'√©tat actuel sans cr√©er de nouvel √©tat"""
        try:
            operator_name = data.get('Op√©rateur', '')
            if not operator_name:
                return True  # Aucun op√©rateur sp√©cifi√©
            
            # R√©cup√©rer l'op√©rateur
            try:
                operateur_obj = Operateur.objects.get(nom_complet__iexact=operator_name)
            except Operateur.DoesNotExist:
                self.errors.append(f"Op√©rateur non trouv√©: {operator_name}")
                return True  # Continuer m√™me si l'op√©rateur n'est pas trouv√©
            
            # V√©rifier si l'op√©rateur a chang√©
            etat_actuel = existing_commande.etat_actuel
            if etat_actuel and etat_actuel.operateur != operateur_obj:
                self._log(f"Mise √† jour de l'op√©rateur pour commande {existing_commande.num_cmd}: {etat_actuel.operateur.nom_complet if etat_actuel.operateur else 'Aucun'} ‚Üí {operateur_obj.nom_complet}")
                
                # Mettre √† jour l'op√©rateur de l'√©tat actuel
                etat_actuel.operateur = operateur_obj
                etat_actuel.save(update_fields=['operateur'])
                
                print(f"üë§ Op√©rateur mis √† jour pour commande {existing_commande.num_cmd}: {operateur_obj.nom_complet}")
            else:
                self._log(f"Op√©rateur inchang√© pour commande {existing_commande.num_cmd}: {operateur_obj.nom_complet}")
            
            return True
            
        except Exception as e:
            error_msg = f"Erreur lors de la mise √† jour de l'op√©rateur pour {existing_commande.num_cmd}: {str(e)}"
            self._log(error_msg, "error")
            return False
    
    def _update_command_status(self, existing_commande, data):
        """Met √† jour le statut d'une commande existante"""
        try:
            # Mettre √† jour le statut si n√©cessaire
            new_status_raw = self._map_status(data.get('Statut', ''))
            if new_status_raw:
                # Statut reconnu - proc√©der √† la mise √† jour
                current_status = existing_commande.etat_actuel.enum_etat.libelle if existing_commande.etat_actuel else 'Non affect√©e'
                
                # PROTECTION CONTRE LA R√âGRESSION D'√âTATS
                # Si la commande a d√©j√† un √©tat avanc√©, ne pas la r√©initialiser √† un √©tat basique
                if self._is_advanced_status(current_status) and self._is_basic_status(new_status_raw):
                    self._log(f"Protection activ√©e lors de la mise √† jour: Commande {existing_commande.num_cmd} garde l'√©tat avanc√© '{current_status}' au lieu de r√©gresser vers '{new_status_raw}'")
                    self.protected_orders_count += 1  # Incr√©menter le compteur de protection
                    new_status_raw = current_status  # Garder le statut actuel
                
                # V√âRIFIER SI LE STATUT A R√âELLEMENT CHANG√â
                if current_status == new_status_raw:
                    self._log(f"Statut identique pour commande {existing_commande.num_cmd}: {current_status} - AUCUN NOUVEL √âTAT CR√â√â")
                    print(f"üìä √âtat inchang√© pour commande existante ID YZ {existing_commande.id_yz}: {current_status}")
                    
                    # Mettre √† jour seulement l'op√©rateur si n√©cessaire (sans cr√©er de nouvel √©tat)
                    self._update_operator_only(existing_commande, data)
                    return True
                else:
                    # Le statut a chang√© - cr√©er un nouvel √©tat
                    self._log(f"Statut diff√©rent pour commande {existing_commande.num_cmd}: {current_status} ‚Üí {new_status_raw}")
                    
                    # R√©cup√©rer l'op√©rateur si sp√©cifi√©
                    operateur_obj = None
                    operator_name = data.get('Op√©rateur', '')
                    if operator_name:
                        try:
                            operateur_obj = Operateur.objects.get(nom_complet__iexact=operator_name)
                        except Operateur.DoesNotExist:
                            self.errors.append(f"Op√©rateur non trouv√©: {operator_name}")
                    
                    # Cr√©er l'√©tat de commande
                    success = self._create_etat_commande(existing_commande, new_status_raw, operateur_obj)
                    
                    if success:
                        print(f"üìä √âtat mis √† jour pour commande existante ID YZ {existing_commande.id_yz}: {current_status} ‚Üí {new_status_raw}")
                    else:
                        print(f"‚ùå √âchec de mise √† jour de l'√©tat pour commande {existing_commande.num_cmd}")
                    
                    return success
            else:
                # Statut non reconnu - utiliser le statut par d√©faut
                self._log(f"Statut non reconnu pour commande {existing_commande.num_cmd} - utilisation du statut par d√©faut 'Non affect√©e'")
                default_status = 'Non affect√©e'
                
                # V√©rifier si le statut par d√©faut est diff√©rent de l'actuel
                current_status = existing_commande.etat_actuel.enum_etat.libelle if existing_commande.etat_actuel else 'Non affect√©e'
                
                if current_status == default_status:
                    self._log(f"Statut par d√©faut identique √† l'actuel pour commande {existing_commande.num_cmd}: {default_status} - AUCUN NOUVEL √âTAT CR√â√â")
                    print(f"üìä √âtat par d√©faut inchang√© pour commande existante ID YZ {existing_commande.id_yz}: {default_status}")
                    
                    # Mettre √† jour seulement l'op√©rateur si n√©cessaire
                    self._update_operator_only(existing_commande, data)
                    return True
                else:
                    # Le statut par d√©faut est diff√©rent - cr√©er un nouvel √©tat
                    self._log(f"Statut par d√©faut diff√©rent de l'actuel pour commande {existing_commande.num_cmd}: {current_status} ‚Üí {default_status}")
                    
                    # Cr√©er/mettre √† jour l'√©tat avec le statut par d√©faut
                    operateur_obj = None
                    operator_name = data.get('Op√©rateur', '')
                    if operator_name:
                        try:
                            operateur_obj = Operateur.objects.get(nom_complet__iexact=operator_name)
                        except Operateur.DoesNotExist:
                            self.errors.append(f"Op√©rateur non trouv√©: {operator_name}")
                    
                    success = self._create_etat_commande(existing_commande, default_status, operateur_obj)
                    if success:
                        print(f"üìä √âtat par d√©faut cr√©√© pour commande existante ID YZ {existing_commande.id_yz}: {default_status}")
                    else:
                        print(f"‚ùå √âchec de cr√©ation de l'√©tat par d√©faut pour commande {existing_commande.num_cmd}")
                    
                    return success
                
        except Exception as e:
            error_msg = f"Erreur lors de la mise √† jour du statut pour {existing_commande.num_cmd}: {str(e)}"
            self._log(error_msg, "error")
            return False
    
    def _update_client_info(self, existing_commande, data, new_address):
        """Met √† jour les informations du client d'une commande"""
        try:
            # Mettre √† jour les informations du client si n√©cessaire
            client_phone_raw = data.get('T√©l√©phone', '')
            client_phone = self._clean_phone_number(client_phone_raw)
            if client_phone and existing_commande.client:
                client_obj = existing_commande.client
                client_nom_prenom = data.get('Client', '').split(' ', 1)
                client_nom = client_nom_prenom[0] if client_nom_prenom else ''
                client_prenom = client_nom_prenom[1] if len(client_nom_prenom) > 1 else ''
                
                client_updated = False
                client_changes = []
                if client_nom and client_obj.nom != client_nom:
                    client_changes.append(f"Nom: '{client_obj.nom}' ‚Üí '{client_nom}'")
                    client_obj.nom = client_nom
                    client_updated = True
                if client_prenom and client_obj.prenom != client_prenom:
                    client_changes.append(f"Pr√©nom: '{client_obj.prenom}' ‚Üí '{client_prenom}'")
                    client_obj.prenom = client_prenom
                    client_updated = True
                if new_address and client_obj.adresse != new_address:
                    client_changes.append(f"Adresse client: '{client_obj.adresse}' ‚Üí '{new_address}'")
                    client_obj.adresse = new_address
                    client_updated = True
                
                if client_updated:
                    client_obj.save()
                    client_full_name = f"{client_obj.nom} {client_obj.prenom}".strip()
                    print(f"üë§ Client mis √† jour: {client_full_name} - {', '.join(client_changes)}")
            
        except Exception as e:
            error_msg = f"Erreur lors de la mise √† jour du client pour {existing_commande.num_cmd}: {str(e)}"
            self._log(error_msg, "error")
    
    def _map_status(self, status):
        """Mappe les statuts du fichier aux libell√©s des √©tats dans la base de donn√©es"""
        print(f"üîÑ === MAPPING STATUT ===")
        print(f"üì• Statut re√ßu: '{status}'")
        print(f"üîç Type de statut: {type(status)}")
        
        status_map = {
            'Non affect√©e': 'Non affect√©e',
            'Affect√©e': 'Affect√©e',
            'Erron√©e': 'Erron√©e',
            'Doublon': 'Doublon',
            '√Ä confirmer': 'En cours de confirmation',
            'En cours de confirmation': 'En cours de confirmation',
            'Confirm√©e': 'Confirm√©e',
            'Annul√©e': 'Annul√©e',
            'En attente': 'En attente',
            'Report√©e': 'Report√©e',
            'Hors zone': 'Hors zone',
            'Injoignable': 'Injoignable',
            'Pas de r√©ponse': 'Pas de r√©ponse',
            'Num√©ro incorrect': 'Num√©ro incorrect',
            '√âchou√©': '√âchou√©',
            'Exp√©di√©e': 'Exp√©di√©e',
            'En pr√©paration': 'En pr√©paration',
            'En livraison': 'En livraison',
            'Livr√©e': 'Livr√©e',
            'Retourn√©e': 'Retourn√©e',
            'Non pay√©': 'Non pay√©',
            'Partiellement pay√©': 'Partiellement pay√©',
            'Pay√©': 'Pay√©',
            # Variantes possibles
            'Erronee': 'Erron√©e',
            'Errone': 'Erron√©e',
            'Erron√©': 'Erron√©e',
            'Doublons': 'Doublon',
            'Non affectee': 'Non affect√©e',
            'Non affect√©': 'Non affect√©e',
            'Affecte': 'Affect√©e',
            'Affect√©': 'Affect√©e',
            'Confirmee': 'Confirm√©e',
            'Confirm√©': 'Confirm√©e',
            'Annulee': 'Annul√©e',
            'Annul√©': 'Annul√©e',
            'Livree': 'Livr√©e',
            'Livr√©': 'Livr√©e',
            'Retournee': 'Retourn√©e',
            'Retourn√©': 'Retourn√©e',
        }
        
        print(f"üìã Nombre total de statuts dans le mapping: {len(status_map)}")
        print(f"üîç Statuts disponibles: {list(status_map.keys())}")
        
        # Nettoyer le statut re√ßu
        print(f"üßπ === NETTOYAGE STATUT ===")
        if status is None:
            print(f"‚ö†Ô∏è Statut re√ßu est None")
            cleaned_status = ''
        else:
            print(f"üìù Statut brut: '{status}' (longueur: {len(str(status))})")
            cleaned_status = str(status).strip()
            print(f"üßπ Statut apr√®s strip: '{cleaned_status}' (longueur: {len(cleaned_status)})")
        
        # Si le statut est vide ou null, retourner None pour indiquer qu'aucun changement n'est n√©cessaire
        if not cleaned_status:
            print(f"‚ùå Statut vide ou null ‚Üí None")
            print(f"üîç === FIN MAPPING STATUT ===\n")
            return None
        
        print(f"‚úÖ Statut non vide, recherche en cours...")
        
        # Chercher dans le dictionnaire (recherche exacte puis insensible √† la casse)
        print(f"üîç === RECHERCHE EXACTE ===")
        if cleaned_status in status_map:
            result = status_map[cleaned_status]
            print(f"‚úÖ Statut trouv√© exactement: '{cleaned_status}' ‚Üí '{result}'")
            print(f"üîç === FIN MAPPING STATUT ===\n")
            return result
        
        print(f"‚ùå Recherche exacte √©chou√©e, tentative insensible √† la casse...")
        
        # Recherche insensible √† la casse
        print(f"üîç === RECHERCHE INSENSIBLE √Ä LA CASSE ===")
        for key, value in status_map.items():
            print(f"üîç Comparaison: '{key.lower()}' vs '{cleaned_status.lower()}'")
            if key.lower() == cleaned_status.lower():
                print(f"‚úÖ Statut trouv√© (insensible √† la casse): '{key}' ‚Üí '{value}'")
                print(f"üîç === FIN MAPPING STATUT ===\n")
                return value
        
        # Si aucun statut ne correspond, retourner None pour indiquer qu'un statut par d√©faut doit √™tre utilis√©
        print(f"‚ùå Aucun statut trouv√© pour '{cleaned_status}'")
        print(f"‚ö†Ô∏è Utilisation du statut par d√©faut 'Non affect√©e'")
        self._log(f"Statut non reconnu: '{cleaned_status}' - utilisation du statut par d√©faut", "warning")
        print(f"üîç === FIN MAPPING STATUT ===\n")
        return None

    def _ensure_enum_etats_exist(self):
        """S'assure que tous les EnumEtatCmd de base existent"""
        print(f"üèóÔ∏è === INITIALISATION DES √âTATS DE BASE ===")
        print(f"üìã V√©rification de l'existence des √©tats de base...")
        
        try:
            from commande.models import EnumEtatCmd
            
            # √âtats de base n√©cessaires pour la synchronisation
            etats_base = [
                {'libelle': 'Non affect√©e', 'ordre': 1, 'couleur': '#EF4444'},
                {'libelle': 'Affect√©e', 'ordre': 2, 'couleur': '#F59E0B'},
                {'libelle': 'Erron√©e', 'ordre': 3, 'couleur': '#DC2626'},
                {'libelle': 'Doublon', 'ordre': 4, 'couleur': '#7C2D12'},
                {'libelle': 'En cours de confirmation', 'ordre': 5, 'couleur': '#3B82F6'},
                {'libelle': 'Confirm√©e', 'ordre': 6, 'couleur': '#10B981'},
                {'libelle': 'Annul√©e', 'ordre': 7, 'couleur': '#6B7280'},
                {'libelle': 'En attente', 'ordre': 8, 'couleur': '#F59E0B'},
                {'libelle': 'Report√©e', 'ordre': 9, 'couleur': '#8B5CF6'},
                {'libelle': 'Hors zone', 'ordre': 10, 'couleur': '#EF4444'},
                {'libelle': 'Injoignable', 'ordre': 11, 'couleur': '#6B7280'},
                {'libelle': 'Pas de r√©ponse', 'ordre': 12, 'couleur': '#6B7280'},
                {'libelle': 'Num√©ro incorrect', 'ordre': 13, 'couleur': '#DC2626'},
                {'libelle': '√âchou√©', 'ordre': 14, 'couleur': '#DC2626'},
                {'libelle': 'Exp√©di√©e', 'ordre': 15, 'couleur': '#3B82F6'},
                {'libelle': 'En pr√©paration', 'ordre': 16, 'couleur': '#F59E0B'},
                {'libelle': 'En livraison', 'ordre': 17, 'couleur': '#8B5CF6'},
                {'libelle': 'Livr√©e', 'ordre': 18, 'couleur': '#10B981'},
                {'libelle': 'Retourn√©e', 'ordre': 19, 'couleur': '#EF4444'},
                {'libelle': 'Non pay√©', 'ordre': 20, 'couleur': '#DC2626'},
                {'libelle': 'Partiellement pay√©', 'ordre': 21, 'couleur': '#F59E0B'},
                {'libelle': 'Pay√©', 'ordre': 22, 'couleur': '#10B981'},
            ]
            
            print(f"üìä Nombre total d'√©tats √† v√©rifier: {len(etats_base)}")
            print(f"üîç √âtats √† v√©rifier: {[etat['libelle'] for etat in etats_base]}")
            
            created_count = 0
            existing_count = 0
            
            print(f"üîÑ === V√âRIFICATION √âTAT PAR √âTAT ===")
            for i, etat_data in enumerate(etats_base, 1):
                print(f"üîç [{i}/{len(etats_base)}] V√©rification de l'√©tat: '{etat_data['libelle']}'")
                
                try:
                    etat, created = EnumEtatCmd.objects.get_or_create(
                        libelle=etat_data['libelle'],
                        defaults={
                            'ordre': etat_data['ordre'],
                            'couleur': etat_data['couleur']
                        }
                    )
                    
                    if created:
                        created_count += 1
                        print(f"‚úÖ NOUVEAU: √âtat '{etat.libelle}' cr√©√© (ID: {etat.id}, Ordre: {etat.ordre}, Couleur: {etat.couleur})")
                        self._log(f"EnumEtatCmd cr√©√©: {etat.libelle}")
                    else:
                        existing_count += 1
                        print(f"‚ÑπÔ∏è EXISTANT: √âtat '{etat.libelle}' d√©j√† pr√©sent (ID: {etat.id}, Ordre: {etat.ordre}, Couleur: {etat.couleur})")
                        
                except Exception as e:
                    print(f"‚ùå ERREUR lors de la v√©rification de l'√©tat '{etat_data['libelle']}': {str(e)}")
                    self._log(f"Erreur lors de la v√©rification de l'√©tat '{etat_data['libelle']}': {str(e)}", "error")
            
            print(f"üìä === R√âSUM√â INITIALISATION ===")
            print(f"‚úÖ √âtats existants: {existing_count}")
            print(f"üÜï Nouveaux √©tats cr√©√©s: {created_count}")
            print(f"üìã Total trait√©: {existing_count + created_count}")
            
            if created_count > 0:
                message = f"Initialisation termin√©e: {created_count} nouveaux √©tats cr√©√©s"
                print(f"üéâ {message}")
                self._log(message)
            else:
                message = "Tous les √©tats de base existent d√©j√†"
                print(f"‚ÑπÔ∏è {message}")
                self._log(message)
            
            print(f"üèóÔ∏è === FIN INITIALISATION DES √âTATS ===\n")
                
        except Exception as e:
            error_msg = f"Erreur lors de l'initialisation des √©tats: {str(e)}"
            print(f"üí• {error_msg}")
            self._log(error_msg, "error")
            print(f"üèóÔ∏è === FIN INITIALISATION DES √âTATS (AVEC ERREUR) ===\n")

    def _create_etat_commande(self, commande, status_libelle, operateur=None):
        """Cr√©e un √©tat de commande avec le libell√© donn√©"""
        try:
            from commande.models import EnumEtatCmd, EtatCommande
            from django.utils import timezone
            from django.db import connection
            from datetime import timedelta
            
            self._log(f"üèóÔ∏è === CR√âATION √âTAT COMMANDE ===")
            self._log(f"üéØ Commande: {commande.num_cmd} (ID YZ: {commande.id_yz})")
            self._log(f"üè∑Ô∏è Statut demand√©: '{status_libelle}'")
            self._log(f"üë§ Op√©rateur: {operateur.nom_complet if operateur else 'Aucun'}")
            
            # V√âRIFIER S'IL EXISTE D√âJ√Ä UN √âTAT R√âCENT AVEC LE M√äME STATUT
            # √âviter de cr√©er des doublons lors de resynchronisations fr√©quentes
            recent_threshold = timezone.now() - timedelta(minutes=5)  # 5 minutes
            
            recent_etat = EtatCommande.objects.filter(
                commande=commande,
                enum_etat__libelle=status_libelle,
                date_debut__gte=recent_threshold
            ).order_by('-date_debut').first()
            
            if recent_etat:
                self._log(f"‚ö†Ô∏è √âtat r√©cent trouv√© avec le m√™me statut '{status_libelle}' pour commande {commande.num_cmd}")
                self._log(f"   üìã ID √©tat existant: {recent_etat.id}")
                self._log(f"   üìã Date d√©but: {recent_etat.date_debut}")
                self._log(f"   üìã Op√©rateur: {recent_etat.operateur.nom_complet if recent_etat.operateur else 'Aucun'}")
                
                # Mettre √† jour seulement l'op√©rateur si n√©cessaire
                if operateur and recent_etat.operateur != operateur:
                    self._log(f"üë§ Mise √† jour de l'op√©rateur: {recent_etat.operateur.nom_complet if recent_etat.operateur else 'Aucun'} ‚Üí {operateur.nom_complet}")
                    recent_etat.operateur = operateur
                    recent_etat.save(update_fields=['operateur'])
                
                # Mettre √† jour le commentaire pour indiquer qu'il s'agit d'une resynchronisation
                commentaire_actuel = recent_etat.commentaire or ""
                if "resynchronisation" not in commentaire_actuel.lower():
                    recent_etat.commentaire = f"{commentaire_actuel} (Resynchronisation Google Sheets)"
                    recent_etat.save(update_fields=['commentaire'])
                
                self._log(f"‚úÖ √âtat existant r√©utilis√© - aucun doublon cr√©√©")
                return True
            
            # Terminer l'√©tat actuel s'il existe
            etat_actuel = commande.etat_actuel
            if etat_actuel:
                self._log(f"üîÑ Terminaison √©tat actuel '{etat_actuel.enum_etat.libelle}' pour commande {commande.num_cmd}")
                etat_actuel.terminer_etat(operateur)
                self._log(f"‚úÖ √âtat actuel termin√© avec succ√®s")
            else:
                self._log(f"‚ÑπÔ∏è Aucun √©tat actuel pour commande {commande.num_cmd}")
            
            # R√©cup√©rer l'√©num√©ration d'√©tat (elle doit maintenant exister)
            try:
                enum_etat = EnumEtatCmd.objects.get(libelle=status_libelle)
                self._log(f"‚úÖ EnumEtatCmd trouv√©: {status_libelle} (ID: {enum_etat.id})")
            except EnumEtatCmd.DoesNotExist:
                # Si l'√©tat n'existe toujours pas, le cr√©er avec des valeurs par d√©faut
                self._log(f"‚ö†Ô∏è EnumEtatCmd non trouv√© pour '{status_libelle}', cr√©ation en cours...")
                enum_etat = EnumEtatCmd.objects.create(
                    libelle=status_libelle,
                    ordre=999,
                    couleur='#6B7280'
                )
                self._log(f"üÜï EnumEtatCmd cr√©√©: {status_libelle} (ID: {enum_etat.id})")
            
            # Cr√©er le nouvel √©tat de commande
            try:
                self._log(f"üèóÔ∏è Cr√©ation de l'EtatCommande...")
                nouvel_etat = EtatCommande.objects.create(
                    commande=commande,
                    enum_etat=enum_etat,
                    date_debut=timezone.now(),
                    operateur=operateur,
                    commentaire=f"√âtat d√©fini lors de la synchronisation depuis Google Sheets"
                )
                
                self._log(f"‚úÖ EtatCommande cr√©√© avec succ√®s!")
                self._log(f"   üìã ID: {nouvel_etat.id}")
                self._log(f"   üìã Commande: {nouvel_etat.commande.num_cmd}")
                self._log(f"   üìã √âtat: {nouvel_etat.enum_etat.libelle}")
                self._log(f"   üìã Date d√©but: {nouvel_etat.date_debut}")
                self._log(f"   üìã Op√©rateur: {nouvel_etat.operateur.nom_complet if nouvel_etat.operateur else 'Aucun'}")
                
                # FORCER LA V√âRIFICATION ET L'INDEXATION
                self._log(f"üîÑ === V√âRIFICATION ET INDEXATION ===")
                
                # 1. Forcer la synchronisation de la base de donn√©es
                connection.commit()
                self._log(f"‚úÖ Transaction commit forc√©")
                
                # 2. Rafra√Æchir la commande depuis la base
                commande.refresh_from_db()
                self._log(f"‚úÖ Commande rafra√Æchie depuis la base")
                
                # 3. V√©rifier que l'√©tat actuel est bien mis √† jour
                etat_actuel_apres = commande.etat_actuel
                if etat_actuel_apres:
                    self._log(f"‚úÖ V√©rification r√©ussie: √âtat actuel apr√®s cr√©ation: '{etat_actuel_apres.enum_etat.libelle}'")
                    self._log(f"   üìã ID √©tat: {etat_actuel_apres.id}")
                    self._log(f"   üìã Date d√©but: {etat_actuel_apres.date_debut}")
                    self._log(f"   üìã Date fin: {etat_actuel_apres.date_fin}")
                else:
                    self._log(f"‚ùå PROBL√àME: Aucun √©tat actuel apr√®s cr√©ation!", "error")
                    
                    # 4. Essayer de r√©cup√©rer l'√©tat cr√©√© manuellement
                    self._log(f"üîç Tentative de r√©cup√©ration manuelle...")
                    etat_test = EtatCommande.objects.filter(commande=commande).order_by('-date_debut').first()
                    if etat_test:
                        self._log(f"üîç √âtat trouv√© manuellement: {etat_test.enum_etat.libelle} (ID: {etat_test.id})", "error")
                        self._log(f"   üìã Date d√©but: {etat_test.date_debut}")
                        self._log(f"   üìã Date fin: {etat_test.date_fin}")
                        
                        # 5. V√©rifier la relation dans la base
                        self._log(f"üîç V√©rification de la relation dans la base...")
                        from django.db import connection
                        with connection.cursor() as cursor:
                            cursor.execute("""
                                SELECT c.id_yz, c.num_cmd, ec.id, ec.enum_etat_id, eec.libelle
                                FROM commande_commande c
                                LEFT JOIN commande_etatcommande ec ON c.id = ec.commande_id
                                LEFT JOIN commande_enumetatcmd eec ON ec.enum_etat_id = eec.id
                                WHERE c.id_yz = %s
                                ORDER BY ec.date_debut DESC
                            """, [commande.id_yz])
                            rows = cursor.fetchall()
                            
                        if rows:
                            self._log(f"üîç Donn√©es brutes de la base: {rows}", "error")
                        else:
                            self._log(f"üîç Aucune donn√©e trouv√©e dans la base!", "error")
                    else:
                        self._log(f"üîç Aucun √©tat trouv√© pour la commande {commande.num_cmd}", "error")
                
                # 6. V√©rification finale
                self._log(f"üîÑ === V√âRIFICATION FINALE ===")
                commande_finale = Commande.objects.get(id_yz=commande.id_yz)
                etat_final = commande_finale.etat_actuel
                
                if etat_final:
                    self._log(f"üéâ SUCC√àS: √âtat final v√©rifi√©: '{etat_final.enum_etat.libelle}'")
                    self._log(f"üéâ === √âTAT CR√â√â AVEC SUCC√àS ===\n")
                    return True
                else:
                    self._log(f"‚ùå √âCHEC: Aucun √©tat final trouv√©!", "error")
                    self._log(f"‚ùå === √âCHEC CR√âATION √âTAT ===\n")
                    return False
                
            except Exception as create_error:
                error_msg = f"‚ùå Erreur lors de la cr√©ation d'EtatCommande pour {commande.num_cmd}: {str(create_error)}"
                self._log(error_msg, "error")
                return False
            
        except Exception as e:
            error_msg = f"Erreur lors de la cr√©ation de l'√©tat '{status_libelle}' pour commande {commande.num_cmd}: {str(e)}"
            self._log(error_msg, "error")
            self.errors.append(error_msg)
            return False
    
    def force_sync_from_row(self, row_number):
        """Force la synchronisation depuis une ligne sp√©cifique"""
        print(f"üîÑ === FORCAGE SYNCHRONISATION DEPUIS LIGNE {row_number} ===")
        print(f"üìç Avant: derni√®re ligne trait√©e = {self.sheet_config.last_processed_row}")
        
        if row_number < 0:
            print(f"‚ùå ERREUR: Num√©ro de ligne invalide: {row_number}")
            return False
        
        # Mettre √† jour la derni√®re ligne trait√©e
        self.sheet_config.last_processed_row = row_number - 1  # -1 car on veut commencer √† la ligne row_number
        self.sheet_config.save(update_fields=['last_processed_row'])
        
        print(f"‚úÖ Synchronisation forc√©e depuis la ligne {row_number}")
        print(f"üìç Derni√®re ligne trait√©e mise √† jour: {self.sheet_config.last_processed_row}")
        print(f"üîÑ Prochaine synchronisation: traitement depuis la ligne {row_number}")
        print(f"üîÑ === FIN FORCAGE SYNCHRONISATION ===\n")
        
        return True
    
    def reset_incremental_sync(self):
        """R√©initialise la synchronisation incr√©mentale pour forcer une synchronisation compl√®te"""
        print(f"üîÑ === R√âINITIALISATION SYNCHRONISATION INCR√âMENTALE ===")
        print(f"üìç Avant: derni√®re ligne trait√©e = {self.sheet_config.last_processed_row}")
        
        # Remettre √† z√©ro la derni√®re ligne trait√©e
        self.sheet_config.last_processed_row = 0
        self.sheet_config.save(update_fields=['last_processed_row'])
        
        print(f"‚úÖ R√©initialisation effectu√©e: derni√®re ligne trait√©e = 0")
        print(f"üîÑ Prochaine synchronisation: traitement de toutes les lignes")
        print(f"üîÑ === FIN R√âINITIALISATION ===\n")
        
        return True
    
    def get_incremental_status(self):
        """Retourne le statut de la synchronisation incr√©mentale"""
        return {
            'last_processed_row': self.sheet_config.last_processed_row,
            'next_sync_start_row': self.sheet_config.next_sync_start_row,
            'total_rows_in_sheet': None,  # Sera mis √† jour lors de la synchronisation
            'rows_to_process_next': None,  # Sera mis √† jour lors de la synchronisation
        }
    
    def sync(self):
        """Synchronise les donn√©es depuis Google Sheets de mani√®re incr√©mentale"""
        print(f"üöÄ === D√âBUT SYNCHRONISATION GOOGLE SHEETS INCR√âMENTALE ===")
        print(f"‚è∞ Heure de d√©but: {timezone.now()}")
        print(f"üë§ D√©clench√© par: {self.triggered_by}")
        print(f"üîß Configuration: {self.sheet_config.name if hasattr(self.sheet_config, 'name') else 'Config inconnue'}")
        
        # R√©cup√©rer la ligne de d√©part pour la synchronisation incr√©mentale
        start_row = self.sheet_config.next_sync_start_row
        print(f"üìç Synchronisation incr√©mentale: reprise depuis la ligne {start_row}")
        
        # Marquer le d√©but de la synchronisation
        self.start_time = timezone.now()
        self.execution_details['started_at'] = self.start_time.isoformat()
        self.execution_details['incremental_start_row'] = start_row
        
        # S'assurer que tous les √©tats de base existent
        print(f"üèóÔ∏è === INITIALISATION DES √âTATS ===")
        self._log("Initialisation des √©tats de commande...")
        self._ensure_enum_etats_exist()
        
        print(f"üîê === AUTHENTIFICATION ===")
        client = self.authenticate()
        if not client:
            print(f"‚ùå √âchec de l'authentification")
            self.end_time = timezone.now()
            self._log_sync('error')
            return False
        print(f"‚úÖ Authentification r√©ussie")
            
        print(f"üìä === R√âCUP√âRATION FEUILLE ===")
        worksheet = self.get_sheet(client)
        if not worksheet:
            print(f"‚ùå √âchec de r√©cup√©ration de la feuille")
            self.end_time = timezone.now()
            self._log_sync('error')
            return False
        print(f"‚úÖ Feuille r√©cup√©r√©e: {worksheet.title}")
            
        try:
            # Enregistrer les informations de la feuille
            print(f"üìã === INFORMATIONS FEUILLE ===")
            self.sheet_title = worksheet.spreadsheet.title
            self.execution_details['spreadsheet_title'] = worksheet.spreadsheet.title
            self.execution_details['worksheet_name'] = worksheet.title
            print(f"üìä Feuille: {worksheet.spreadsheet.title}")
            print(f"üìã Onglet: {worksheet.title}")
            
            # R√©cup√©rer toutes les donn√©es
            print(f"üì• === R√âCUP√âRATION DONN√âES ===")
            print(f"‚è≥ R√©cup√©ration de toutes les donn√©es...")
            all_data = worksheet.get_all_values()
            print(f"‚úÖ Donn√©es r√©cup√©r√©es")
            
            if not all_data:
                error_msg = "‚ùå Aucune donn√©e trouv√©e dans la feuille"
                print(error_msg)
                self.errors.append("Aucune donn√©e trouv√©e dans la feuille")
                self.end_time = timezone.now()
                self._log_sync('error')
                return False
                
            # Extraire les en-t√™tes et les donn√©es
            headers = all_data[0]
            rows = all_data[1:]
            
            print(f"üìä === ANALYSE DONN√âES ===")
            print(f"üìã En-t√™tes d√©tect√©s ({len(headers)} colonnes): {headers}")
            print(f"üìä Nombre total de lignes: {len(all_data)}")
            print(f"üìä Lignes de donn√©es: {len(rows)}")
            print(f"üìä Ligne d'en-t√™tes: 1")
            
            # V√©rifier si la synchronisation incr√©mentale est possible
            if start_row > 1:
                if start_row > len(all_data):
                    print(f"‚ö†Ô∏è ATTENTION: La ligne de d√©part ({start_row}) d√©passe le nombre total de lignes ({len(all_data)})")
                    print(f"üîÑ R√©initialisation de la synchronisation depuis le d√©but")
                    start_row = 1
                    self.sheet_config.last_processed_row = 0
                    self.sheet_config.save(update_fields=['last_processed_row'])
                else:
                    print(f"‚úÖ Synchronisation incr√©mentale: traitement des lignes {start_row} √† {len(all_data)}")
            else:
                print(f"üîÑ Premi√®re synchronisation: traitement de toutes les lignes")
            
            # Filtrer les lignes √† traiter selon la synchronisation incr√©mentale
            rows_to_process = rows[start_row - 1:] if start_row > 1 else rows
            print(f"üìä Lignes √† traiter: {len(rows_to_process)} (sur {len(rows)} total)")
            
            # Afficher les premiers en-t√™tes pour v√©rification
            if rows_to_process:
                print(f"üîç Premi√®re ligne de donn√©es √† traiter: {dict(zip(headers, rows_to_process[0]))}")
                if len(rows_to_process) > 1:
                    print(f"üîç Deuxi√®me ligne de donn√©es √† traiter: {dict(zip(headers, rows_to_process[1]))}")
            
            # Enregistrer les statistiques
            self.total_rows = len(all_data)
            self.execution_details['headers'] = headers
            self.execution_details['total_rows'] = len(all_data)
            self.execution_details['data_rows'] = len(rows)
            self.execution_details['rows_to_process'] = len(rows_to_process)
            self.execution_details['incremental_start_row'] = start_row
            
            print(f"üöÄ === D√âBUT TRAITEMENT LIGNES ===")
            print(f"üìà Total lignes √† traiter: {len(rows_to_process)}")
            
            # Traiter chaque ligne
            for i, row in enumerate(rows_to_process, start_row + 1):  # Commencer √† start_row + 1 car start_row est 1-indexed
                print(f"\nüìù === TRAITEMENT LIGNE {i} ===")
                
                # V√©rifier si la ligne est vide
                if not any(cell.strip() for cell in row if cell):
                    print(f"‚ö†Ô∏è Ligne {i} ignor√©e: ligne compl√®tement vide")
                    self._log(f"Ligne {i} ignor√©e : ligne compl√®tement vide")
                    self.skipped_rows += 1
                    continue
                    
                if len(row) == len(headers):  # V√©rifier que la ligne a le bon nombre de colonnes
                    print(f"‚úÖ Ligne {i} valide: {len(row)} colonnes vs {len(headers)} en-t√™tes")
                    print(f"üîç Aper√ßu: {dict(zip(headers[:3], row[:3]))}...")
                    
                    success = self.process_row(row, headers)
                    if success:
                        print(f"‚úÖ Ligne {i} trait√©e avec succ√®s")
                        self._log(f"Ligne {i} trait√©e avec succ√®s")
                        self.processed_rows += 1
                        
                        # Mettre √† jour la derni√®re ligne trait√©e pour la synchronisation incr√©mentale
                        self.sheet_config.last_processed_row = i
                        self.sheet_config.save(update_fields=['last_processed_row'])
                        print(f"üìç Derni√®re ligne trait√©e mise √† jour: {i}")
                    else:
                        print(f"‚ùå √âchec traitement ligne {i}")
                        self._log(f"√âchec traitement ligne {i}")
                        self.skipped_rows += 1
                else:
                    error_msg = f"‚ùå Ligne {i} ignor√©e: nombre de colonnes incorrect ({len(row)} vs {len(headers)})"
                    print(error_msg)
                    self._log(error_msg, "error")
                    self.skipped_rows += 1
            
            # Marquer la fin de la synchronisation
            self.end_time = timezone.now()
            
            # Calculer les statistiques finales d√©taill√©es
            duration = (self.end_time - self.start_time).total_seconds()
            self.execution_details.update({
                'finished_at': self.end_time.isoformat(),
                'duration_seconds': duration,
                'processed_rows': self.processed_rows,
                'skipped_rows': self.skipped_rows,
                'records_imported': self.records_imported,
                'success_rate': (self.processed_rows / len(rows_to_process) * 100) if rows_to_process else 0,
                'errors_count': len(self.errors),
                'final_processed_row': self.sheet_config.last_processed_row,
                
                # Nouvelles statistiques d√©taill√©es
                'new_orders_created': self.new_orders_created,
                'existing_orders_updated': self.existing_orders_updated,
                'existing_orders_skipped': self.existing_orders_skipped,
                'duplicate_orders_found': self.duplicate_orders_found,
                'insertion_avoided_count': self.duplicate_orders_found,  # Nombre d'insertions √©vit√©es
                'protected_orders_count': self.protected_orders_count,  # Nombre de commandes prot√©g√©es
            })
            
            # Message de notification d√©taill√©
            notification_parts = []
            
            # Cas sp√©cial : Aucune nouvelle commande mais des commandes existantes d√©tect√©es
            if self.new_orders_created == 0 and self.duplicate_orders_found > 0:
                notification_parts.append(f"‚ùå Aucune nouvelle commande trouv√©e")
                notification_parts.append(f"üìã {self.duplicate_orders_found} commandes existantes d√©tect√©es dans la feuille")
            elif self.new_orders_created > 0:
                notification_parts.append(f"‚úÖ {self.new_orders_created} nouvelles commandes cr√©√©es")
            
            # Ajouts des autres types d'actions
            if self.existing_orders_updated > 0:
                notification_parts.append(f"üîÑ {self.existing_orders_updated} commandes existantes mises √† jour")
            if self.existing_orders_skipped > 0:
                notification_parts.append(f"‚ûñ {self.existing_orders_skipped} commandes existantes inchang√©es")
            if self.protected_orders_count > 0:
                notification_parts.append(f"üõ°Ô∏è {self.protected_orders_count} commandes prot√©g√©es contre la r√©gression d'√©tat")
            
            # Message par d√©faut si rien ne s'est pass√©
            if not notification_parts:
                notification_parts.append("‚ö†Ô∏è Aucune donn√©e valide trouv√©e")
            
            # Ajouter l'information sur la synchronisation incr√©mentale
            if start_row > 1:
                notification_parts.append(f"üìç Synchronisation incr√©mentale: lignes {start_row} √† {self.sheet_config.last_processed_row}")
            else:
                notification_parts.append(f"üîÑ Synchronisation compl√®te: toutes les lignes trait√©es")
            
            self.execution_details['sync_summary'] = " | ".join(notification_parts)
            
            self._log(f"R√©sum√© synchronisation: {self.execution_details['sync_summary']}")
            
            # D√©terminer le statut final
            if self.errors:
                status = 'partial' if self.records_imported > 0 else 'error'
            else:
                status = 'success'
                
            self._log_sync(status)
            return status == 'success' or status == 'partial'
            
        except Exception as e:
            self.end_time = timezone.now()
            self.errors.append(f"Erreur de synchronisation: {str(e)}")
            self._log_sync('error')
            return False
    
    def _log_sync(self, status):
        """Enregistre un log de synchronisation avec statistiques d√©taill√©es"""
        SyncLog.objects.create(
            status=status,
            records_imported=self.records_imported,
            errors='\n'.join(self.errors) if self.errors else None,
            sheet_config=self.sheet_config,
            triggered_by=self.triggered_by,
            
            # Champs d√©taill√©s existants
            start_time=self.start_time,
            end_time=self.end_time,
            total_rows=self.total_rows,
            processed_rows=self.processed_rows,
            skipped_rows=self.skipped_rows,
            sheet_title=self.sheet_title,
            execution_details=self.execution_details,
            
            # Nouvelles statistiques d√©taill√©es
            new_orders_created=self.new_orders_created,
            existing_orders_updated=self.existing_orders_updated,
            existing_orders_skipped=self.existing_orders_skipped,
            duplicate_orders_found=self.duplicate_orders_found,
            protected_orders_count=self.protected_orders_count,
        )

# --- Configuration for Google Sheets API ---
# In a production setting, use environment variables or Django settings for credentials.
# For simplicity, assuming 'service_account.json' is available in the project root.
def get_gc_client():
    try:
        # Assumes service_account.json is in the working directory or specified via GOOGLE_APPLICATION_CREDENTIALS
        return gspread.service_account()
    except Exception as e:
        raise Exception(f"Failed to initialize gspread client. Ensure 'service_account.json' is correctly configured: {e}")

# Helper to parse product string
def parse_product_string(product_str):
    # Example format: "ESP HOM YZ650 - 42/ÿ£ÿ≥ŸàÿØ ÿ£ÿ®Ÿäÿ∂ / noir blanc"
    # We need: product_name, size, color
    product_name = None
    size = None
    color = None

    if ' - ' in product_str:
        parts = product_str.split(' - ', 1) # Split only on the first occurrence
        product_name = parts[0].strip()
        details_part = parts[1].strip()

        if '/' in details_part:
            size_and_color_parts = details_part.split('/', 1) # Split only on the first '/'
            size = size_and_color_parts[0].strip()
            if len(size_and_color_parts) > 1:
                color = size_and_color_parts[1].strip()
                # Further clean color to remove redundant language part if present
                if ' / ' in color:
                    color = color.split(' / ')[0].strip() # Take the first language part
        else:
            # If no '/', maybe the whole detail part is the size or color
            size = details_part # Or handle as a generic descriptor if not strictly size/color
    else:
        # If no ' - ', the whole string is the product name
        product_name = product_str.strip()

    return product_name, size, color

def sync_google_sheet_data(config_id):
    config = GoogleSheetConfig.objects.get(id=config_id)
    sync_log = SyncLog.objects.create(config=config, status='PENDING', start_time=timezone.now())

    try:
        gc = get_gc_client()
        spreadsheet = gc.open_by_url(config.sheet_url)
        worksheet = spreadsheet.worksheet(config.worksheet_name)
        data = worksheet.get_all_records() # Get data as list of dictionaries

        processed_rows = 0
        successful_imports = 0
        failed_imports = 0
        logs = []

        for row_data in data:
            with transaction.atomic():
                try:
                    # Map CSV headers to model fields (case-sensitive from CSV)
                    numero_commande = row_data.get('N¬∞ Commande')
                    statut_csv = row_data.get('Statut')
                    operateur_name = row_data.get('Op√©rateur')
                    client_full_name = row_data.get('Client') # e.g., "Housni", "ŸÜÿπŸäŸÖÿ© ÿ£ŸÖÿßÿ≥Ÿà"
                    client_tel_raw = row_data.get('T√©l√©phone', '')
                    client_tel = GoogleSheetSync.clean_phone_number(client_tel_raw)
                    adresse = row_data.get('Adresse')
                    ville_name = row_data.get('Ville')
                    produit_str = row_data.get('Produit')
                    quantite = row_data.get('Quantit√©')
                    prix = row_data.get('Prix')
                    date_creation_str = row_data.get('Date Cr√©ation')
                    motifs = row_data.get('Motifs')

                    if not numero_commande:
                        raise ValueError("Skipping row: 'N¬∞ Commande' is missing.")
                    
                    # V√©rifier que le statut est pr√©sent (obligatoire)
                    if not statut_csv or not statut_csv.strip():
                        raise ValueError(f"Skipping row: 'Statut' is missing for order '{numero_commande}'. Status is mandatory.")
                    
                    # 1. Create or get Client
                    # Client name from CSV is often just a full name. We need nom and prenom.
                    # Simple heuristic: last word is nom, rest is prenom.
                    client_nom_parts = client_full_name.split() if client_full_name else []
                    client_nom = client_nom_parts[-1] if client_nom_parts else ''
                    client_prenom = ' '.join(client_nom_parts[:-1]) if len(client_nom_parts) > 1 else client_full_name # Fallback if only one word

                    client, created_client = Client.objects.get_or_create(
                        numero_tel=client_tel,
                        defaults={
                            'nom': client_nom,
                            'prenom': client_prenom,
                            'adresse': adresse, # Use address from CSV
                            # 'email': None, # Not in CSV
                        }
                    )
                    if created_client:
                        logs.append(f"Created new client: {client.get_full_name()} ({client.numero_tel}) for order {numero_commande}")

                    # 2. Get Operateur (assuming Operateur exists in your DB)
                    operateur_obj = None
                    if operateur_name:
                        try:
                            # Use exact match for operator name
                            operateur_obj = Operateur.objects.get(nom_complet__iexact=operateur_name)
                        except Operateur.DoesNotExist:
                            logs.append(f"Operator '{operateur_name}' not found for order '{numero_commande}'. Skipping operator assignment.")
                        except Operateur.MultipleObjectsReturned:
                             logs.append(f"Multiple operators found for '{operateur_name}'. Skipping operator assignment for order '{numero_commande}'.")


                    # 3. Get Ville (assuming Ville exists in your DB)
                    ville_obj = None
                    if ville_name:
                        try:
                            # Use exact match for city name
                            ville_obj = Ville.objects.get(nom__iexact=ville_name)
                        except Ville.DoesNotExist:
                            logs.append(f"City '{ville_name}' not found for order '{numero_commande}'. Storing city name directly.")
                            pass # We will store ville_name directly in Commande if obj not found
                        except Ville.MultipleObjectsReturned:
                            logs.append(f"Multiple cities found for '{ville_name}'. Storing city name directly for order '{numero_commande}'.")
                            pass # Store city name directly

                    # 4. Parse Date Creation
                    date_cmd = timezone.now() # Default to now if parsing fails
                    try:
                        # Attempt to parse multiple date formats present in the CSV
                        # YYYY-MM-DD HH:MM:SS
                        if len(date_creation_str) == 19 and date_creation_str[4] == '-' and date_creation_str[13] == ':':
                            date_cmd = datetime.strptime(date_creation_str, '%Y-%m-%d %H:%M:%S')
                        # YYYY-MM-DD
                        elif len(date_creation_str) == 10 and date_creation_str[4] == '-':
                            date_cmd = datetime.strptime(date_creation_str, '%Y-%m-%d')
                        # DD/MM/YYYY (or MM/DD/YYYY, try DD/MM first) - "27/04/2025"
                        elif '/' in date_creation_str:
                            try:
                                date_cmd = datetime.strptime(date_creation_str, '%d/%m/%Y')
                            except ValueError:
                                date_cmd = datetime.strptime(date_creation_str, '%m/%d/%Y') # Try MM/DD/YYYY as fallback
                        
                        date_cmd = timezone.make_aware(date_cmd) # Make it timezone aware
                    except (ValueError, TypeError) as e:
                        logs.append(f"Could not parse date '{date_creation_str}' for order '{numero_commande}': {e}. Using current time.")
                        date_cmd = timezone.now()


                    # 5. Create or Update Commande
                    commande, created_commande = Commande.objects.update_or_create(
                        num_cmd=numero_commande,
                        defaults={
                            'date_cmd': date_cmd,
                            'total_cmd': float(prix) if prix else 0.0,
                            'adresse': adresse,
                            'client': client,
                            'ville_init': ville_name, # Storing name, not object, based on CSV
                            'produit_init': produit_str, # Store raw product string
                            'origine': 'GSheet',
                        }
                    )
                    if created_commande:
                        logs.append(f"Successfully created order: {commande.numero_commande}")
                        
                        # SUPPRIM√â : Cr√©ation du panier vide - un panier doit toujours contenir des articles
                        # Le panier sera cr√©√© plus tard quand des articles seront ajout√©s √† la commande
                        logs.append(f"Order created without cart - cart will be created when articles are added")
                    else:
                        logs.append(f"Successfully updated order: {commande.numero_commande}")

                    successful_imports += 1

                except Exception as e:
                    failed_imports += 1
                    logs.append(f"Error processing row for order '{row_data.get('N¬∞ Commande', 'N/A')}': {e}. Row data: {row_data}")
                    transaction.set_rollback(True) # Ensure rollback for this row

            processed_rows += 1

        sync_log.status = 'COMPLETED'
        sync_log.successful_imports = successful_imports
        sync_log.failed_imports = failed_imports
        sync_log.log_messages = "\\n".join(logs)
        sync_log.end_time = timezone.now()
        sync_log.save()
        return True, "Synchronization completed."

    except Exception as e:
        sync_log.status = 'FAILED'
        sync_log.log_messages = f"Synchronization failed unexpectedly: {e}\\n" + "\\n".join(logs)
        sync_log.end_time = timezone.now()
        sync_log.save()
        return False, f"Synchronization failed unexpectedly: {e}"